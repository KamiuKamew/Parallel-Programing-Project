# NTT 选题：多线程实验

本次多线程实验分为三个方案，朴素算法，四分算法和 CRT 算法，朴素算法为基础要求，后两个为进阶要求，如果可以实现 CRT 算法，就不必再实现四分算法，但**必须实现朴素算法**，最终保障 CRT 算法得分不低于四分算法得分。

> 所以应该实现**朴素算法+CRT 算法**。

NTT 选题要求在本次实验**不允许使用 SIMD 优化**，但你可以把**多线程和向量化的结合放在期末报告**中。

## 5.1 朴素多线程优化

对于基础版的 NTT 多线程优化，实现方法较为简单，由于第二三层循环相当于遍历了一遍多项式数组，显然可以对第三层循环进行多线程优化,类似高斯消元，因此代码实现较为简单，只需要注意线程同步正确。

```cpp
for(int mid = 1; mid < limit; mid <<= 1) {
    for(int j = 0; j < limit; j += (mid << 1)) {
        int w = 1;// 旋转因子
        for(int k = 0; k < mid; k++，w = w ∗ Wn) {// 对这层循环进行优化
            // 运算主体
        }
    }
}
```

## 5.2 多分多线程优化

即使在 SIMD 实验中未实现四分的 NTT，也可以在多线程这里开始。

对于非二分的 NTT，需要判断多项式长度，如果多项式长度不等于 $4^n$ (即多项式长度等于 $2^{2k+1}$)，由于每次枚举的步长乘积等于 4，需要预处理第一层或最后一层的循环后，才能进行四分。

如果线程数等于 4，每个线程负责对应需要归并的四块数据的每一块。

## 5.3 CRT 多线程优化

提供一个全新的多线程优化思路，在 SIMD 的实验指导书中提到了大模数的 NTT 方法，其本质即**任意模数** NTT，如果你是在洛谷或 oiwiki 中学习的 NTT 基础知识，也能看到任意模数 NTT 的原理，即使用**中国剩余定理**(CRT)**合并大模数**。

对于任意模数 NTT 的模板，通常采用**三模数 NTT 合并**，CRT 多线程优化的思想类似任意模数 NTT，如果让每一个线程都使用不同的小模数，最终使用 CRT 将结果合并。

如果要实现此多线程优化，需要在**实现多模数 NTT 合并**后才能实现 pthread 优化，当模数越大时，多线程的优化效果越明显。

你可以仿照任意模数 NTT(**三**模数合并) 的模板仿推出任意模数 NTT(**多**模数合并) 的公式，也可以自己上网寻找相关博客，另外以下给出了两篇应用了 CRT 合并 NTT 以加速大模数的同态加密论文，有更详细的原理和优化的证明，当然 CRT 合并 NTT 的重要性在超大模数(往往远大于 64 bit)时才明显，对于同态加密库(CKKS 等)，会经常使用超大模数进行加密，因此如果实现了本优化，要求最终**需要测试一个大于 32 bit 的模数**。

- A Full RNS Variant of FV like Somewhat Homomorphic Encryption Schemes
- A Full RNS Variant of Approximate Homomorphic Encryption
- Approximate CRT-Based Gadget Decomposition and Application to TFHE Blind Rotation

有关多线程优化 NTT 的论文还有很多，可以自行搜索。

## 总结

1. 应该实现**朴素算法+CRT 算法**。
2. 本次实验**不允许使用 SIMD 优化**。
3. 需要在**实现多模数 NTT 合并**后才能实现 pthread 优化。
4. 需要仿照任意模数 NTT(**三**模数合并) 的模板仿推出任意模数 NTT(**多**模数合并) 的公式。（注：最后实现的是**多**模数合并）
5. 最终**需要测试一个大于 32 bit 的模数**。

## 助教 tip

- 报告
  - 对比算法复杂度：对比用 simd 前和 simd 后的优化比，而不是对比 NTT 和朴素算法之间的复杂度。
- 脚本
  - 参数 1：实验编号
  - 参数 2：申请核心数（默认为 1）
  - 参数 3：申请线程数
- OpenMP：比较简单，自己写吧
- pthread：提交的
- 这里强调了**提交代码的方式**，具体详见回放。
-

## 其它

- **Pthread 编程范式：**
  - 建议使用**静态线程**。
- **生成线程所要执行函数的参数问题：**
  - 由于只有一个 void 指针的参数，可以创建一个数据结构，将所需要的各种参数如线程 id，问题规模大小等打包起来通过指针转换来传递。注意对于均分任务时，当问题规模不等于线程数倍数时，对于分配最后一部分计算任务的线程不要直接使用 my_first+my_n 计算 my_last，可根据线程 id 将 n 作为该线程的 my_last。对于推荐的范式来说，可直接在线程函数内完成这些工作，就无需传递参数了。
- **尽量避免频繁的创建和销毁线程**
- **不同任务划分策略：**
  - 如果需要对矩阵进行划分，可能需要考虑行划分和列划分的区别。两种划分策略在负载均衡上可能会有细微差异，而在同步方面会有差异，cache 利用方面也会有不同。
- **临界区问题**
  - 在并行算法中，经常会遇到需要多个线程修改全局变量，而这些线程可能需要修改同一位置的情况，这时就需要考虑使用临界区。
  - 在使用 pthread 库进行多线程编程时，可以使用 pthread_mutex_t（互斥锁）来创建临界区。互斥锁可以保证在任意时刻只有一个线程可以获得锁，其他线程必须等待该线程释放锁后才能获得锁并进入临界区。
  - 当然，除了互斥锁以外，还可以使用条件变量、信号量等方法，请同学们参考课程 PPT 或查阅资料。
- **负载均衡问题**
  - 如果你不得不划分出一些计算量大小不一的任务，不便于手动分配给每个线程，可以考虑构建任务池（任务队列），把待完成的任务放进去。每当一个线程完成当前任务后，立刻到任务池中再选取一个任务执行，直到所有任务被完成。不过在这一过程中，一定要正确使用信号量、锁等方法来避免访存冲突。
